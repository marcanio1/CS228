package edu.iastate.cs228.hw03;/**   A class of bags whose entries are stored in a chain of doubly linked nodes.       @author	Eric Marcanio    */public class DoublyLinkedBag<T> implements BagInterface<T>{	private DoublyLinkedNode firstNode;       // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag()	{		firstNode = null;		numberOfEntries =0;	} // end default constructor	public boolean add(T newEntry)	{		DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry);		newNode.next = firstNode; // Make new node reference rest of chain                                // (firstNode is null if chain is empty)                firstNode = newNode;      // New node is at beginning of chain		numberOfEntries++;      		return true;	} // end add	public T[] toArray()	{		@SuppressWarnings("unchecked")	    T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast	    int index = 0;	    DoublyLinkedNode currentNode = firstNode;	    while ((index < numberOfEntries) && (currentNode != null))	      {	         result[index] = currentNode.data;	         index++;	         currentNode = currentNode.next;	      } 	      				return result;	} // end toArray	public boolean isEmpty() 	{		return numberOfEntries == 0;	} // end isEmpty	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;		int counter = 0;	    DoublyLinkedNode currentNode = firstNode;	      while ((counter < numberOfEntries) && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	         {	            frequency++;	         } // end if	         	         counter++;	         currentNode = currentNode.next;	      } // end while			return frequency;	} // end getFrequencyOf	public boolean contains(T anEntry)	{		 boolean found = false;	      DoublyLinkedNode currentNode = firstNode;	      	      while (!found && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	            found = true;	         else	            currentNode = currentNode.next;	      } // end while		      	      return found;	} // end contains	public void clear() 	{		while (!isEmpty()) 	         remove();	} // end clear	public T remove()	{		T result = null;	      if (firstNode != null)	      {	         result = firstNode.data; 	         firstNode = firstNode.next; // Remove first node from chain	         numberOfEntries--;	      } // end if			return result;	} // end remove	public boolean remove(T anEntry) 	{		boolean result = false;	    DoublyLinkedNode nodeN = getReferenceTo(anEntry);	      	      if (nodeN != null)	      {	         nodeN.data = firstNode.data; // Replace located entry with entry in first node	         	         firstNode = firstNode.next;  // Remove first node	         numberOfEntries--;	         	         result = true;	      } // end if	         			return result;	} // end remove	public T replace(T replacement)	{		DoublyLinkedNode spot = firstNode;				if( spot == null)			return null;				T stuff = spot.data;				spot.data = replacement;				return stuff;	}		public void removeEvery(T anEntry)	{		DoublyLinkedNode place= firstNode;				while(place!= null) {			if(place.data.equals(anEntry)) {				place.data = remove();				place= place.next;			}			else				place= place.next;		}	}	private DoublyLinkedNode getReferenceTo(T anEntry)	{		boolean found = false;		DoublyLinkedNode currentNode = firstNode;				while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while     		return currentNode;	}		/**	 Override the equals method of Object class so that it returns true when the contents of two DoublyLinkedBags are same. Note that two equal DoublyLinkedBags contain the same number of entries, and each entry occurs in each DoublyLinkedBag the same number of times. I.e., the elements in two do not need to be in exact same location.	 	 Before checking the contents inside this method make sure that the passed in object is not null, is of the same runtime class, and the lengths are same. If any of these fail you can return false. Otherwise, you base your return results on contents. (At the start you can also do the quick check if both refer to the same object in memory.)	 	*/	//@SuppressWarnings("unchecked")	@Override	public boolean equals(Object obj)	{		if( obj == null) 			return false;				DoublyLinkedNode place = firstNode;		if((T)obj instanceof DoublyLinkedBag) {		DoublyLinkedBag<T> sameO = (DoublyLinkedBag<T>)obj;						while(place!= null) {			T stuff = place.data;			if(sameO.contains(stuff)){     //If they have same thing it will check if it occurs for the same amount of time				if(sameO.getFrequencyOf(stuff)!= getFrequencyOf(stuff))					return false;			}			else				return false;			place = place.next;		}		}		return true;	}		/**	 Returns String representation of the items in this bag.	 For example, it would return [A, B, C] if bag had three Strings "A", "B", and "C".	 	 @return String representation of items in this bag enclosed in square brackets, separated by comma and a single space (see example above). You can rely on the fact that items' proper toString method was implemented. In this method ONLY if you need to you can use String class's methods. Also, ONLY in this method you can use fully qualified name for StringBuffer class, and use all of its methods.	*/	@Override	public String toString()	{		DoublyLinkedNode cur = firstNode;		String returnthis = "[";		while(cur != null) {			returnthis += cur.data;			cur = cur.next;			if(cur != null) {				returnthis+= ", ";			}												}		return returnthis += "]"; // this is returned in case bag is empty.	}		// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode	{		private T	data;					// Entry in bag		private DoublyLinkedNode next;		// Link to next node		private DoublyLinkedNode prev;	// Link to previous node		private DoublyLinkedNode(T dataPortion)		{			this(dataPortion, null, null);			} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode,				DoublyLinkedNode previousNode)		{			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor			} // end DoublyLinkedNode	@Override	public BagInterface<T> union(BagInterface<T> anotherBag) {		// TODO Auto-generated method stub		return null;	}	@Override	public BagInterface<T> intersection(BagInterface<T> anotherBag) {		// TODO Auto-generated method stub		return null;	}	@Override	public BagInterface<T> difference(BagInterface<T> anotherBag) {		// TODO Auto-generated method stub		return null;	}	} // end DoublyLinkedBag