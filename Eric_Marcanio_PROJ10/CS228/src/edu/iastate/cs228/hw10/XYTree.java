package edu.iastate.cs228.hw10;import java.util.LinkedList;import edu.iastate.cs228.hw09.BinaryNode;/** * A class that implements an xy-tree. *  * @author Eric Marcanio *  *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{  private BinaryNode<T> root;  public XYTree()  {	root = null;  }  public XYTree(T rootData)  {	if (rootData != null)	  root = new BinaryNode<>(rootData);	else	  throw new IllegalArgumentException();  }  public void addAllPoints(T[] entries)  {	if (entries == null || entries.length == 0)	  throw new IllegalArgumentException();	for (T t : entries)	  addPoint(t);  }  /**   *   * Adds a new point into the xy-tree if it does not    * exist in this tree. Check an example under Canvas.   * Also, check the comment of levelOrderTraverse.   *    */  public void addPoint(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();    Boolean bool = false;	BinaryNode<T> entry = new BinaryNode<T>(anEntry);	BinaryNode<T> pointer = root;	int count = 2;		if(isEmpty()) {		root = entry;		return;	}		while(!pointer.isLeaf()&& !bool) {		if(count % 2 == 0) {			if(anEntry.x < pointer.getData().x) {				pointer = pointer.getLeftChild();				if(pointer.getData().equals(anEntry))					return;				count++;			}			else if(anEntry.x >= pointer.getData().x && pointer.hasRightChild()) {				pointer = pointer.getRightChild();				if(pointer.getData().equals(anEntry))					return;				count++;			}		}		else {			if(pointer.getData().equals(anEntry))				return;			bool = true;		}			if(anEntry.y > pointer.getData().y) {				pointer = pointer.getRightChild();				count++;			}else {				pointer = pointer.getLeftChild();				count++;			}			}	if(count % 2 == 0) {		if(anEntry.x< pointer.getData().x) {			pointer.setLeftChild(entry);		}else {			pointer.setRightChild(entry);		}	}		else {			if(anEntry.y < pointer.getData().y) {				pointer.setLeftChild(entry);			}			else {				pointer.setRightChild(entry);			}		}		return;  }  /**   * Returns true if a point exists in this tree,    * otherwise false.   *    */  public boolean contains(T anEntry)  {	  if (anEntry == null)	      throw new IllegalArgumentException();	    String[] stran = levelOrderArr();	    	    for(String str : stran)	    {	        if(str.equals("(" + anEntry.x + ", " + anEntry.y + ")"))	            return true;	    }	    return false;  }  /**   * Makes it into a string   * @return A tree array   */  private String[] levelOrderArr()  {      String[] arr = new String[levelOrderTraverse().size()];      int counter = 0;      for(String s : levelOrderTraverse())      {          arr[counter] = s;          counter++;      }      return arr;  }  /**   * Returns a list of points in level-order traversal.    * In this method you are allowed to use    * java.util.LinkedList class.   *    *    * For example,   *    * XYTree<Point> xy = new XYTree<>();    *    * xy.addAllPoints(new Point[]{   * 	new Point(5, 3),    *    new Point(5, 2),    *    new Point(10, 7),    *    new Point(9, 1),    *    new Point(6, 8),    *    new Point(6, 8),    *    new Point(10, 1)   * });   * System.out.println(xy.levelOrderTraverse());   *    * would print   *    * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]   *    */  public java.util.LinkedList<String> levelOrderTraverse()  {	   LinkedList<BinaryNode<T>> queue = new LinkedList<BinaryNode<T>>();	   LinkedList<String> ret = new LinkedList<String>();	      queue.add(root);	      while (!queue.isEmpty()) {	          BinaryNode<T> tempNode = queue.poll();	          ret.add("(" + tempNode.getData().x + ", " + tempNode.getData().y + ")");	          if (tempNode.getLeftChild() != null) {	              queue.add(tempNode.getLeftChild());	          }	          if (tempNode.getRightChild() != null) {	              queue.add(tempNode.getRightChild());	          }	      }	      return  ret;  }  @Override  @SuppressWarnings("unchecked")  public T getRootData()  {	if (isEmpty())	  throw new RuntimeException("Empty Tree!");	else	  return (T) root.getData().clone();  }  @Override  public boolean isEmpty()  {	return root == null;  }  @Override  public void clear()  {	root = null;  }  @Override  public int getHeight()  {	return root.getHeight();  }  @Override  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  }}